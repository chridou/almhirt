akka {
	actor {
		#guardian-supervisor-strategy = "almhirt.akkaconf.GuardianStrategyConfigurator"
	}
}


almhirt {
	context {
	   max-init-duration = 10 seconds
	   use-dedicated-futures-dispatcher = true
	   use-dedicated-cruncher-dispatcher = true
	   use-dedicated-blockers-dispatcher = false
	   
	   use-dedicated-apps-dispatcher = true 
	   use-dedicated-apps-futures-executor = true 
	
	   
	   dispatchers {
		    futures-dispatcher {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "fork-join-executor"
				# Configuration for the fork join pool
				fork-join-executor {
				# Min number of threads to cap factor-based parallelism number to
				parallelism-min = 2
				# Parallelism (threads) ... ceil(available processors * factor)
				parallelism-factor = 2.0
				# Max number of threads to cap factor-based parallelism number to
				parallelism-max = 10
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 10	    
		   }
		    blockers-dispatcher {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "thread-pool-executor"
				# Configuration for the thread pool
				thread-pool-executor {
				# minimum number of threads to cap factor-based core number to
				core-pool-size-min = 1
				# No of core threads ... ceil(available processors * factor)
				core-pool-size-factor = 2.0
				# maximum number of threads to cap factor-based number to
				core-pool-size-max = 8
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100
		    }
		    cruncher-dispatcher {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "thread-pool-executor"
				# Configuration for the thread pool
				thread-pool-executor {
				# minimum number of threads to cap factor-based core number to
				core-pool-size-min = 2
				# No of core threads ... ceil(available processors * factor)
				core-pool-size-factor = 2.0
				# maximum number of threads to cap factor-based number to
				core-pool-size-max = 4
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100
		    }
		    
		   
		    apps-dispatcher {
				# Must be one of the following
				# Dispatcher, PinnedDispatcher, or a FQCN to a class inheriting
				# MessageDispatcherConfigurator with a public constructor with
				# both com.typesafe.config.Config parameter and
				# akka.dispatch.DispatcherPrerequisites parameters.
				# PinnedDispatcher must be used together with executor=thread-pool-executor.
				type = "Dispatcher"
				 
				# Which kind of ExecutorService to use for this dispatcher
				# Valid options:
				# - "default-executor" requires a "default-executor" section
				# - "fork-join-executor" requires a "fork-join-executor" section
				# - "thread-pool-executor" requires a "thread-pool-executor" section
				# - A FQCN of a class extending ExecutorServiceConfigurator
				executor = "default-executor"
				 
				# This will be used if you have set "executor = "default-executor"".
				# If an ActorSystem is created with a given ExecutionContext, this
				# ExecutionContext will be used as the default executor for all
				# dispatchers in the ActorSystem configured with
				# executor = "default-executor". Note that "default-executor"
				# is the default value for executor, and therefore used if not
				# specified otherwise. If no ExecutionContext is given,
				# the executor configured in "fallback" will be used.
				default-executor {
					fallback = "fork-join-executor"
				}
				 
				# This will be used if you have set "executor = "fork-join-executor""
				fork-join-executor {
					# Min number of threads to cap factor-based parallelism number to
					parallelism-min = 8
					 
					# The parallelism factor is used to determine thread pool size using the
					# following formula: ceil(available processors * factor). Resulting size
					# is then bounded by the parallelism-min and parallelism-max values.
					parallelism-factor = 3.0
					 
					# Max number of threads to cap factor-based parallelism number to
					parallelism-max = 64
				}
				 
				# This will be used if you have set "executor = "thread-pool-executor""
				thread-pool-executor {
					# Keep alive time for threads
					keep-alive-time = 60s
					 
					# Min number of threads to cap factor-based core number to
					core-pool-size-min = 8
					 
					# The core pool size factor is used to determine thread pool core size
					# using the following formula: ceil(available processors * factor).
					# Resulting size is then bounded by the core-pool-size-min and
					# core-pool-size-max values.
					core-pool-size-factor = 3.0
					 
					# Max number of threads to cap factor-based number to
					core-pool-size-max = 64
					 
					# Minimum number of threads to cap factor-based max number to
					# (if using a bounded task queue)
					max-pool-size-min = 8
					 
					# Max no of threads (if using a bounded task queue) is determined by
					# calculating: ceil(available processors * factor)
					max-pool-size-factor = 3.0
					 
					# Max number of threads to cap factor-based max number to
					# (if using a bounded task queue)
					max-pool-size-max = 64
					 
					# Specifies the bounded capacity of the task queue (< 1 == unbounded)
					task-queue-size = -1
					 
					# Specifies which type of task queue will be used, can be "array" or
					# "linked" (default)
					task-queue-type = "linked"
					 
					# Allow core threads to time out
					allow-core-timeout = on
				}
				 
				# How long time the dispatcher will wait for new actors until it shuts down
				shutdown-timeout = 1s
				 
				# Throughput defines the number of messages that are processed in a batch
				# before the thread is returned to the pool. Set to 1 for as fair as possible.
				throughput = 5
				 
				# Throughput deadline for Dispatcher, set to 0 or negative for no deadline
				throughput-deadline-time = 0ms
				 
				# For BalancingDispatcher: If the balancing dispatcher should attempt to
				# schedule idle actors using the same dispatcher when a message comes in,
				# and the dispatchers ExecutorService is not fully busy already.
				attempt-teamwork = on
				 
				# If this dispatcher requires a specific type of mailbox, specify the
				# fully-qualified class name here; the actually created mailbox will
				# be a subtype of this type. The empty string signifies no requirement.
				mailbox-requirement = ""
			}
			
		    apps-futures-dispatcher {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "fork-join-executor"
				# Configuration for the fork join pool
				fork-join-executor {
				# Min number of threads to cap factor-based parallelism number to
				parallelism-min = 2
				# Parallelism (threads) ... ceil(available processors * factor)
				parallelism-factor = 2.0
				# Max number of threads to cap factor-based parallelism number to
				parallelism-max = 10
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 10	    
		   }
			
		    
	 	}
	}
	
   	streams {
	 use-dedicated-dispatcher = true
	 soak-commands = true
	 soak-events = true
	 event-buffer-size = 100
	 command-buffer-size = 10
	 initial-commands-fanout-buffer-size = 8
	 max-commands-fanout-buffer-size = 16
	 initial-events-fanout-buffer-size = 8
	 max-events-fanout-buffer-size = 16
     
     dedicated-dispatcher {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "thread-pool-executor"
			# Configuration for the thread pool
			thread-pool-executor {
			# minimum number of threads to cap factor-based core number to
			core-pool-size-min = 2
			# No of core threads ... ceil(available processors * factor)
			core-pool-size-factor = 2.0
			# maximum number of threads to cap factor-based number to
			core-pool-size-max = 8
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100
     }
   }
	
	herder {
		herding-dogs {
			failures {
				ignore-consecutive-circuit-problems = true
				history-size = 100
				unwrap-failures = true
			}
			missed-events {
				history-size = 100
				unwrap-failures = true
			}
			rejected-commands {
				history-size = 100
				unwrap-failures = true
				downgrade-command-representations = true
			}
			information {
				history-size = 100
			}
			runtime {
				polling-interval = 1 minute
				warning-percentage = 70.0
				critical-percentage = 90.0
				history-size = 100
			}
		}
	}

	components {
		misc {
			event-sink-hub {
				enabled = true
				with-black-hole-if-empty = true
				buffer-size = 100


				event-publishers {
					event-log-writer {
						enabled = true
						warning-threshold = 2 seconds
						auto-connect = true
						resolve-settings {
							resolve-wait = 3 seconds
							retry-pause = 1 seconds
							retry-max-time = 30 seconds
							retry-infinite-loop-pause = 30 seconds
						}
						circuit-control {
						    max-failures = 5
					        failures-warn-threshold = 3
					        call-timeout = 5 seconds
					        reset-timeout = 5 minutes
						}
						circuit-state-reporting-interval = 2 minutes
					}
				
					http-event-publishers {
						
						elastic-search-event-publisher {
						}
						
						a-http-event-publisher {
						}
					}
				}

			}
		
			command-status-tracker {
				target-cache-size = 1000
				shrink-cache-at = 1100
				check-timeout-interval = 5 seconds
				auto-connect = true
			}
			
			command-endpoint {
			  	max-tracking-duration = 1 minute
			  	auto-connect = true
				resolve-settings {
					resolve-wait = 3 seconds
					retry-pause = 1 seconds
					retry-max-time = 30 seconds
					retry-infinite-loop-pause = 30 seconds
				}
			}
		}
		
		views {
			aggregate-root-views {
				#default
				snapshot-storage-path = none
				resolve-settings {
					resolve-wait = 3 seconds
					retry-pause = 1 seconds
					retry-max-time = 30 seconds
					retry-infinite-loop-pause = 30 seconds
				}
	
				event-buffer-size = 100
	
	
				#specific setting for an AggregateRootViews
				a-aggregate-root-views {
					event-buffer-size = 100
				}
			}
			
						
			unprojected-view {
				return-to-unitialized-after = 10 minutes
				rebuild-timeout = 10 seconds
			}
			
		}
		
		aggregates {
			aggregate-root-nexus {
			}
	
			aggregate-root-hive {
				#default
				snapshot-storage-path = none
				resolve-settings {
					resolve-wait = 3 seconds
					retry-pause = 1 seconds
					retry-max-time = 30 seconds
					retry-infinite-loop-pause = 30 seconds
				}
				
				command-buffer-size = 16
				enqueued-events-throttling-threshold = 8
			
				#specific setting for an AggregateRootViews
				a-aggregate-root-hive {
					command-buffer-size = 100
					enqueued-events-throttling-threshold = 6
				}
				
			}
				
			aggregate-root-drone {
				return-to-unitialized-after = 5 minutes
			}
		}
		
		event-logs {
			aggregate-root-event-log {
			}
			
			event-log {
			}
		}
		
	}
	
	http {
		endpoints {
			event-log-endpoint {
			}
			
			command-endpoint {
			}
		}
	}
}