akka {
	actor {
		#guardian-supervisor-strategy = "almhirt.akkaconf.GuardianStrategyConfigurator"
	}
}


almhirt {
	context {
	   max-init-duration = 5 seconds
	   use-dedicated-futures-dispatcher = true
	   use-dedicated-cruncher-dispatcher = true
	   use-dedicated-blockers-dispatcher = false
	
	   streams {
	     use-dedicated-dispatcher = true
	     soak-commands = true
	     soak-events = true
	     initial-commands-fanout-buffer-size = 8
	     max-commands-fanout-buffer-size = 16
	     initial-events-fanout-buffer-size = 8
	     max-events-fanout-buffer-size = 16
	   }
	   
	   dispatchers {
		    futures-dispatcher = {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "fork-join-executor"
				# Configuration for the fork join pool
				fork-join-executor {
				# Min number of threads to cap factor-based parallelism number to
				parallelism-min = 2
				# Parallelism (threads) ... ceil(available processors * factor)
				parallelism-factor = 2.0
				# Max number of threads to cap factor-based parallelism number to
				parallelism-max = 10
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100	    
		   }
		    blockers-dispatcher = {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "thread-pool-executor"
				# Configuration for the thread pool
				thread-pool-executor {
				# minimum number of threads to cap factor-based core number to
				core-pool-size-min = 1
				# No of core threads ... ceil(available processors * factor)
				core-pool-size-factor = 2.0
				# maximum number of threads to cap factor-based number to
				core-pool-size-max = 8
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100
		    }
		    cruncher-dispatcher = {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "thread-pool-executor"
				# Configuration for the thread pool
				thread-pool-executor {
				# minimum number of threads to cap factor-based core number to
				core-pool-size-min = 2
				# No of core threads ... ceil(available processors * factor)
				core-pool-size-factor = 2.0
				# maximum number of threads to cap factor-based number to
				core-pool-size-max = 8
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100
		    }
		    streaming-dispatcher = {
				# Dispatcher is the name of the event-based dispatcher
				type = Dispatcher
				# What kind of ExecutionService to use
				executor = "thread-pool-executor"
				# Configuration for the thread pool
				thread-pool-executor {
				# minimum number of threads to cap factor-based core number to
				core-pool-size-min = 2
				# No of core threads ... ceil(available processors * factor)
				core-pool-size-factor = 2.0
				# maximum number of threads to cap factor-based number to
				core-pool-size-max = 8
				}
				# Throughput defines the maximum number of messages to be
				# processed per actor before the thread jumps to the next actor.
				# Set to 1 for as fair as possible.
				throughput = 100
		    }
	 	}
	}

	components {
		event-sink-hub {
			buffer-size = 100
		}
	}
}

