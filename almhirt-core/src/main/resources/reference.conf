akka {
	actor {
		guardian-supervisor-strategy = "almhirt.akkaconf.GuardianStrategyConfigurator"
	}
}


almhirt {
	# The actorsystem's name when the system is generated by Almhirt.
	system-name = "almhirt"
	# If true, use the actorsystem's logging mechanism as the Almhirt-logger. Otherwise create a logger with LogBack
	#useAkkaLogging = true
    durations {
      short = 3 seconds
      medium = 10 seconds
      long = 30 seconds
      extra-long = 2 minutes
    }

	repositories {
		cell-cache-ask-max-duration = 2 seconds
		cell-ask-max-duration = 4 seconds
	}
    
    aggregate-root-cell {
       get-ar-warn-duration-threshold = 5 seconds
       update-ar-warn-duration-threshold = 5 seconds
       get-ar-timeout = 8 seconds
       update-ar-timeout = 8 seconds
       # time for which a cell delays the reporting of the cell state on a transition to "DoesNotExist". Does not apply for a transition to error state.
       cell-state-reporting-delay = 10 seconds
    }
    
    aggregate-root-cell-source {
       # set to false, if you don't want to have the cache state modified in any way.
       # all cache related settings will have no meaning
       enable-cache-control = true
       # the interval in which the cache gets cleaned up
       cache-control-heart-beat-interval = 1 minute
       # remove cached aggregate roots when older than 'max-cached-aggregate-root-age'
       remove-cached-aggregate-roots = true
       # maximum age of a cached aggregate root
       max-cached-aggregate-root-age = 5 minutes
       # remove cells that reported that their aggregate root does not exist after 'max-does-not-exist-age'. Also applies to cells in error state
       remove-does-not-exist-cells = true
       # maximum age of cells with a non existing aggregate root or in error state
       max-does-not-exist-age = 1 minute
       # remove cells that reported that they are uninitialized after 'max-uninitialized-age'
       # if set to true, a 'max-uninitialized-age' of 0 may cause implications since a cell starts in uninitialized state.
       remove-uninitialized-cells = true
       # the maximum age of an uninitialized cell
       max-uninitialized-age = 1 minute
    }
    
    command-executor {
    	max-execution-time-per-command-warn-threshold = 5 seconds
    }
    
    execution-state-tracker {
    	target-size = 2000
    	debug = false
    	clean-up-threshold = 3000
    	clean-up-interval = 30 seconds
    	check-subscriptions = true
    	check-subscriptions-interval = 5 seconds
    	check-subscriptions-warn-age-lvl1 = 11 seconds
    	check-subscriptions-warn-age-lvl2 = 17 seconds
    	subscriptions-ok-reporting-threshold = 100
    	state-changed-message-warning-age = 5 seconds
    }

    executors {
      futures = "almhirt.dispatchers.futures-dispatcher"
      sync-io = "almhirt.dispatchers.sync-io-dispatcher"
      number-cruncher = "almhirt.dispatchers.number-cruncher-dispatcher"
    }
    
    dispatchers {
	    futures-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "fork-join-executor"
			# Configuration for the fork join pool
			fork-join-executor {
			# Min number of threads to cap factor-based parallelism number to
			parallelism-min = 2
			# Parallelism (threads) ... ceil(available processors * factor)
			parallelism-factor = 2.0
			# Max number of threads to cap factor-based parallelism number to
			parallelism-max = 10
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100	    
	   }
	    sync-io-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "thread-pool-executor"
			# Configuration for the thread pool
			thread-pool-executor {
			# minimum number of threads to cap factor-based core number to
			core-pool-size-min = 1
			# No of core threads ... ceil(available processors * factor)
			core-pool-size-factor = 2.0
			# maximum number of threads to cap factor-based number to
			core-pool-size-max = 8
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100
	    }
	    number-cruncher-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "thread-pool-executor"
			# Configuration for the thread pool
			thread-pool-executor {
			# minimum number of threads to cap factor-based core number to
			core-pool-size-min = 2
			# No of core threads ... ceil(available processors * factor)
			core-pool-size-factor = 2.0
			# maximum number of threads to cap factor-based number to
			core-pool-size-max = 8
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100
	    }
	}
}

