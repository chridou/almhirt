package almhirt.testkit

import almhirt.core._
import almhirt.almvalidation.kit._
import com.typesafe.config._

trait AlmhirtFromAkkaTestKitWithoutConfiguration { self: AlmhirtTestKit ⇒
  private val almhirtAndCloseHandleF = Almhirt.notFromConfig(self.system).awaitResult(scala.concurrent.duration.Duration(5, "s"))
  private val almhirtAndCloseHandle = almhirtAndCloseHandleF.resultOrEscalate

  override val theAlmhirt = almhirtAndCloseHandle._1
}


trait AlmhirtFromAkkaTestKitWithConfiguration { self: AlmhirtTestKit ⇒
  def config: Config
  private val almhirtAndCloseHandleF = Almhirt(self.system, config).awaitResult(scala.concurrent.duration.Duration(5, "s"))
  private val almhirtAndCloseHandle = almhirtAndCloseHandleF.resultOrEscalate

  override val theAlmhirt = almhirtAndCloseHandle._1
}

object TestConfiguration {
  val cfgStr = 
    """
almhirt {
	# The actorsystem's name when the system is generated by Almhirt.
	system-name = "almhirt-test"
	# If true, use the actorsystem's logging mechanism as the Almhirt-logger. Otherwise create a logger with LogBack
	#useAkkaLogging = true
    durations {
	  # Durations are set as milliseconds
      short = 3 seconds
      medium = 10 seconds
      long = 20 seconds
      extra-long = 1 minute
    }
    executors {
      futures = "almhirt.dispatchers.futures-dispatcher"
      sync-io = "almhirt.dispatchers.sync-io-dispatcher"
      number-cruncher = "almhirt.dispatchers.number-cruncher-dispatcher"
    }
    
    aggregate-root-cell-source {
       enable-cache-control = true
       cache-control-heart-beat-interval = 1 minute
       remove-old-cells = true
       max-cell-cache-age = 5 minutes
       remove-does-not-exist-cells = true
       max-does-not-exist-age = 1 minute
    }
    
    dispatchers {
	    futures-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "fork-join-executor"
			# Configuration for the fork join pool
			fork-join-executor {
			# Min number of threads to cap factor-based parallelism number to
			parallelism-min = 2
			# Parallelism (threads) ... ceil(available processors * factor)
			parallelism-factor = 2.0
			# Max number of threads to cap factor-based parallelism number to
			parallelism-max = 10
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100	    
	   }
	    sync-io-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "thread-pool-executor"
			# Configuration for the thread pool
			thread-pool-executor {
			# minimum number of threads to cap factor-based core number to
			core-pool-size-min = 2
			# No of core threads ... ceil(available processors * factor)
			core-pool-size-factor = 2.0
			# maximum number of threads to cap factor-based number to
			core-pool-size-max = 4
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100
	    }
	    number-cruncher-dispatcher = {
			# Dispatcher is the name of the event-based dispatcher
			type = Dispatcher
			# What kind of ExecutionService to use
			executor = "thread-pool-executor"
			# Configuration for the thread pool
			thread-pool-executor {
			# minimum number of threads to cap factor-based core number to
			core-pool-size-min = 2
			# No of core threads ... ceil(available processors * factor)
			core-pool-size-factor = 2.0
			# maximum number of threads to cap factor-based number to
			core-pool-size-max = 4
			}
			# Throughput defines the maximum number of messages to be
			# processed per actor before the thread jumps to the next actor.
			# Set to 1 for as fair as possible.
			throughput = 100
	    }
	}
}
    """
    
    val default = ConfigFactory.parseString(cfgStr).withFallback(ConfigFactory.load())
}